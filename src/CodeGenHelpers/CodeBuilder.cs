using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

#pragma warning disable IDE0079
#pragma warning disable IDE0090
#pragma warning disable IDE1006
#nullable enable
namespace CodeGenHelpers
{
    public sealed class CodeBuilder
    {
        private const string DefaultAutoGeneratedMessage = @"This code was generated.

Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.";
        private string? _autoGeneratedMessage;
        private readonly List<string> _namespaceImports = new List<string>();
        private readonly List<string> _assemblyAttributes = new List<string>();
        private readonly Queue<IBuilder> _builders = new Queue<IBuilder>();
        private bool _topLevel;
        private NullableState _nullable = NullableState.Default;

        private CodeBuilder(string? clrNamespace = null, IndentStyle indentStyle = IndentStyle.Spaces)
        {
            Namespace = clrNamespace;
            IndentStyle = indentStyle;
        }

        public string? Namespace { get; }

        public IndentStyle IndentStyle { get; }

        public IReadOnlyList<ClassBuilder> Classes => _builders.OfType<ClassBuilder>().ToList();

        public IReadOnlyList<RecordBuilder> Records => _builders.OfType<RecordBuilder>().ToList();

        public IReadOnlyList<EnumBuilder> Enums => _builders.OfType<EnumBuilder>().ToList();

        public IReadOnlyList<DelegateBuilder> Delegates => _builders.OfType<DelegateBuilder>().ToList();

        public CodeBuilder TopLevelNamespace() => TopLevelNamespace(true);

        public CodeBuilder TopLevelNamespace(bool topLevel)
        {
            _topLevel = topLevel;
            return this;
        }

        public CodeBuilder Nullable() => Nullable(NullableState.Enable);

        public CodeBuilder Nullable(NullableState nullable)
        {
            _nullable = nullable;
            return this;
        }

        public static CodeBuilder CreateInGlobalNamespace(IndentStyle indentStyle = IndentStyle.Spaces) =>
            new CodeBuilder(indentStyle: indentStyle)
                .TopLevelNamespace();

        public static CodeBuilder Create(string clrNamespace, IndentStyle indentStyle = IndentStyle.Spaces) =>
            new CodeBuilder(clrNamespace, indentStyle);

        public static CodeBuilder Create(INamespaceSymbol namespaceSymbol, IndentStyle indentStyle = IndentStyle.Spaces) =>
            Create(namespaceSymbol.ToString(), indentStyle);

        public static ClassBuilder Create(ITypeSymbol typeSymbol, IndentStyle indentStyle = IndentStyle.Spaces)
        {
            var builder = Create(typeSymbol.ContainingNamespace, indentStyle);
            return builder.AddClass(typeSymbol.Name)
                .WithAccessModifier(typeSymbol.DeclaredAccessibility)
                .OfType(typeSymbol.TypeKind);
        }

        public CodeBuilder AddNamespaceImport(string importedNamespace)
        {
            var value = Regex.Replace(importedNamespace, @"^using\w+", string.Empty).Replace(";", string.Empty);
            if (!_namespaceImports.Contains(value))
                _namespaceImports.Add(value);

            return this;
        }

        public CodeBuilder AddNamespaceImport(ISymbol symbol)
        {
            return AddNamespaceImport(symbol.ContainingNamespace.ToString());
        }

        public CodeBuilder AddNamespaceImport(INamespaceSymbol symbol)
        {
            return AddNamespaceImport(symbol.ToString());
        }

        public CodeBuilder AddAssemblyAttribute(string attribute)
        {
            _assemblyAttributes.Add(attribute);
            return this;
        }

        public ClassBuilder AddClass(string name)
        {
            var builder = new ClassBuilder(name, this);
            _builders.Enqueue(builder);
            return builder;
        }

        public ClassBuilder AddClass(ITypeSymbol symbol)
        {
            return AddClass(symbol.Name);
        }

        internal ClassBuilder AddClass(ClassBuilder builder)
        {
            _builders.Enqueue(builder);
            builder.Builder = this;
            return builder;
        }

        public RecordBuilder AddRecord(string name)
        {
            var builder = new RecordBuilder(name, this);
            _builders.Enqueue(builder);
            return builder;
        }

        internal RecordBuilder AddRecord(RecordBuilder builder)
        {
            _builders.Enqueue(builder);
            builder.Builder = this;
            return builder;
        }

        public EnumBuilder AddEnum(string name)
        {
            var builder = new EnumBuilder(name, this);
            _builders.Enqueue(builder);
            return builder;
        }

        internal EnumBuilder AddEnum(EnumBuilder builder)
        {
            _builders.Enqueue(builder);
            builder.Builder = this;
            return builder;
        }

        public DelegateBuilder AddDelegate(string name)
        {
            var builder = new DelegateBuilder(name, this);
            _builders.Enqueue(builder);
            return builder;
        }

        public CodeBuilder WithAutoGeneratedMessage(string message)
        {
            _autoGeneratedMessage = message;
            return this;
        }

        public void Clear()
        {
            _namespaceImports.Clear();
            _assemblyAttributes.Clear();
            _builders.Clear();
        }

        private CodeWriter BuildInternal()
        {
            var writer = new CodeWriter(IndentStyle);
            writer.AppendLine("//------------------------------------------------------------------------------");
            writer.AppendLine("// <auto-generated>");
            var autoGeneratedMessage = string.IsNullOrEmpty(_autoGeneratedMessage) ? DefaultAutoGeneratedMessage : _autoGeneratedMessage;
            var lines = Regex.Replace(autoGeneratedMessage, @"\r\n", "\n").Split('\n');
            foreach(var line in lines)
            {
                writer.AppendLine($"//     {line}".Trim());
            }
            writer.AppendLine("// </auto-generated>");
            writer.AppendLine("//------------------------------------------------------------------------------");
            writer.NewLine();
            var namespaces = _namespaceImports.Distinct().ToList();
            var systemNamespaces = GetImports(ref namespaces, x => x.StartsWith("System"));
            var nonsystemNamespaces = GetImports(ref namespaces, x => !x.StartsWith("System") && !x.Contains("=") && !x.Contains("static"));
            var namespaceAlias = GetImports(ref namespaces, x => x.Contains("="));

            WriteNamespace(systemNamespaces, ref writer);
            WriteNamespace(nonsystemNamespaces, ref writer);
            WriteNamespace(namespaceAlias, ref writer);
            WriteNamespace(namespaces, ref writer);

            if(_namespaceImports.Count > 0)
                writer.NewLine();

            if(_nullable != NullableState.Default)
                writer.AppendLine($"#nullable {_nullable}".ToLowerInvariant());

            WriteAssemblyAttributes(_assemblyAttributes, ref writer);
            if(_topLevel)
            {
                if (Namespace is not null)
                {
                    writer.AppendLine($"namespace {Namespace};");
                    writer.NewLine();
                }

                WriteBody(writer);
                return writer;
            }

            using (writer.Block($"namespace {Namespace}"))
            {
                WriteBody(writer);
            }

            return writer;
        }

        private void WriteBody(CodeWriter writer)
        {
            var clone = new Queue<IBuilder>(_builders);

            while (clone.Any())
            {
                var output = clone.Dequeue();
                output.Write(writer);

                if (clone.Any())
                    writer.NewLine();
            }
        }

        private static IEnumerable<string> GetImports(ref List<string> namespaces, Func<string, bool> predicate)
        {
            var output = namespaces.Where(predicate).ToArray();
            foreach (var str in output)
                namespaces.Remove(str);

            return output.OrderBy(x => x);
        }

        public string Build()
        {
            var writer = BuildInternal();
            return writer.Render();
        }

        public override string ToString()
        {
            return Build();
        }

        private static void WriteAssemblyAttributes(IEnumerable<string> assemblyAttributes, ref CodeWriter writer)
        {
            if (!assemblyAttributes.Any())
            {
                return;
            }

            foreach (var attr in assemblyAttributes.Distinct().OrderBy(x => x))
            {
                if (string.IsNullOrEmpty(attr))
                    continue;

                var output = attr;
                if (attr[0] != '[' || !attr.StartsWith("[assembly:"))
                {
                    output = $"[assembly: {attr}]";
                }

                output = output.Replace("[[", "[").Replace("]]", "]");
                writer.AppendLine(output);
            }
        }

        private static void WriteNamespace(IEnumerable<string> namespaces, ref CodeWriter writer)
        {
            foreach (var import in namespaces)
                writer.AppendLine($"using {import};");
        }
    }
}
